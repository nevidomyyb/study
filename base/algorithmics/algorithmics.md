1. Complexity Analysis
Understanding how to measure and compare algorithm efficiency.

Big-O Notation: Time and space complexity; common classes (O(1), O(log n), O(n), etc.).
Best, Average, and Worst-Case Analysis: Evaluate performance in different scenarios.
Amortized Analysis: Applications in algorithms with cumulative cost, e.g., dynamic arrays.

2. Sorting and Searching Algorithms
Fundamental algorithms for organizing and retrieving data.

Sorting: Bubble sort, merge sort, quicksort, and their time/space trade-offs.
Searching: Binary search, linear search, and conditions for using each.
Divide and Conquer: How algorithms like quicksort and merge sort break problems into subproblems.
Traveling Salesman Problem

5. Dynamic Programming and Greedy Algorithms
Techniques for solving optimization problems.

Dynamic Programming: Breaking problems into overlapping subproblems; examples like Fibonacci, knapsack problem.
Greedy Algorithms: Making locally optimal choices; examples like activity selection and Huffman coding.
Optimization Problems: Understanding when to use greedy vs. dynamic programming.